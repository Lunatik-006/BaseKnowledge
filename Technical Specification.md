# ТЗ (v1.1) — Telegram Bot + Mini App → Obsidian-заметки + Поиск (RAG)

**Стек:**

- **Платформа:** Telegram Bot + **Telegram Mini App (WebApp)**
  - Фронтенд — **Next.js** (Mini App — это веб‑клиент внутри Telegram; полностью на Python Mini App сделать нельзя).
  - Бэкенд — **Python (FastAPI)**.
- **LLM через Replicate:**
  - Разбиение/генерация заметок — `openai/gpt-5-structured`.
  - Поиск/ответ из контекста — `openai/gpt-5-nano`.
  - Эмбеддинги — `BGE-M3` (или `bge-small`) через Replicate.
- **Векторное хранилище:** Milvus (standalone, Docker).
- **Реляционная БД:** PostgreSQL (метаданные, пользователи, сессии/квоты).
- **OS/Infra:** Ubuntu + Docker/Compose.
- **Файлы заметок:** локальная файловая система (**без S3**).

---

## 0) Цели

1) Принимать **любые тексты** (и короткие посты, и длинные подборки) → получать **структурированные Obsidian‑заметки** (Markdown с YAML), автоссылки и MOC.
2) Давать **поиск по базе** (RAG): векторный поиск → компактная LLM‑сшивка ответа.
3) Минимум трения: «переслал боту → получил заметки и/или ZIP» + **Mini App** для просмотра.

---

## 1) Нефункциональные требования

- Контейнеризация: Docker Compose.
- Конфигурация: `.env` (секреты/токены через env).
- Кросс‑языковая поддержка (RU/EN) на уровне LLM и эмбеддингов.
- Простая масштабируемость: вынести индексацию в воркеры/очереди при росте.

---

## 2) Архитектура (высокоуровнево)

**Сервисы:**

- `api` — FastAPI: REST, Telegram webhook, RAG‑поиск.
- `miniapp` — Next.js: UI просмотра заметок, поиск, «Open in Obsidian».
- `milvus` — векторный индекс (коллекции `chunks` / `notes_meta`).
- `postgres` — метаданные/пользователи/сессии/квоты.
- (опц.) `worker` — фоновые задачи (позже).

**Пайплайн ingest → notes:**

```
raw text → LLM (structured insights) → генерация .md → сохранение на FS
                                       ↓
                                 чанкинг → эмбеддинги → Milvus.upsert
```

**Пайплайн search:**

```
query → embed → Milvus.search (top‑k) → LLM (gpt‑5‑nano) сшивка → answer.md
```

---

## 3) Структура проекта (ООП‑ориентированно, кратко)

```
monorepo/
├─ apps/
│  ├─ api/       # FastAPI: ingest, notes, search, export, telegram webhook
│  ├─ miniapp/   # Next.js: список, просмотр, поиск, «open in obsidian», zip
│  └─ bot/       # (опц.) тонкий слой; можно встроить в api
├─ libs/
│  ├─ core/      # доменные сущности (DTO), ошибки, конфиг
│  ├─ llm/       # абстракция LLM + Replicate‑клиент (5‑structured / 5‑nano)
│  ├─ rag/       # эмбеддинги, чанкинг, Milvus‑индекс, конструктор ответа
│  ├─ db/        # PostgreSQL (SQLAlchemy/psycopg), модели и репозитории
│  └─ storage/   # FS‑операции: запись/чтение .md, экспорт ZIP
├─ infra/
│  ├─ docker/    # Dockerfiles, docker‑compose.yml
│  └─ scripts/   # утилиты импорта/экспорта, миграции индекса
├─ tests/        # unit/integration (минимально)
├─ .env.example
└─ README.md
```

**Основные классы/интерфейсы (без кода):**

- `LLMClient`: `generate_structured_notes`, `render_note_markdown`, `answer_from_context`.
- `EmbeddingsProvider`: `embed_texts(list[str]) -> list[list[float]]`.
- `VectorIndex` (Milvus): `upsert_chunks`, `search(query_vec, k)`.
- `NotesStorage` (FS): `save_note`, `read_note`, `export_zip`.
- UseCases: `IngestText`, `Search`.

---

## 4) Данные и схемы

### PostgreSQL (минимум)

- `users` (id, telegram_id, created_at).
- `notes` (id, title, tags[], topic_id?, created_at, file_path, source_url?, author?, dt?, channel?).
- `chunks` (id, note_id → notes.id, pos, anchor?).  
  > Текст чанков и эмбеддинги **не** в Postgres — текст хранится на FS, эмбеддинги в Milvus.

### Milvus

- `chunks`:
  - `chunk_id` (pk), `note_id` (string), `pos` (int), `text` (string),
  - `embedding` (float_vector, dim=768).
  - Индекс: HNSW (`M=16`, `efConstruction=200`), search‑параметры `ef=64`.
- `notes_meta` (опц.): `note_id` / `title` для быстрых «см. также».

### Файловая система

- Vault:

```
vault/
  00_MOC/topics_index.md
  10_Notes/<slug>.md
```

- Формат `.md`: YAML (title, created, tags, source_*, topic_id), тело (Summary, Тезисы, Применение, Источники, См. также).

---

## 5) REST API (кратко)

- `POST /ingest/text` — `{text, source_url?, author?, dt?, channel?}` → `{notes:[{id, title, file_path}]}`.
- `GET /notes` — список заметок.
- `GET /notes/{id}` — содержимое (md/мета).
- `POST /search` — `{query, k?}` → `{answer_md, items:[{id, title, url, snippet}]}`.
- `GET /export/zip` — архив vault.
- `POST /telegram/webhook/<secret>` — приём апдейтов.

---

## 6) Telegram Bot + Mini App  *(Drop-in замена раздела)*

### 6.1. Telegram Bot — требования

**Цель:** нулевое трение для ввода контента (короткие посты и длинные подборки), запуск пайплайна `ingest → notes → index`, выдача ссылок/файлов и вход в Mini App.

**Режимы и команды**

- `/start` — краткая инструкция + кнопка «Открыть Mini App».
- `/mode` — переключатель:

  - **One-to-One:** «1 пост → 1 заметка».
  - **Curate:** «несколько постов/подборка → набор атомарных заметок».
- `/zip` — собрать последние N созданных заметок в архив и выслать пользователю.
- `/help` — список функций и ограничения.
- (Опц.) `/lang` — RU/EN.

**Типы входящих сообщений**

- **Текст** (в т.ч. форварды из каналов/чатов).
- **Медиа с подписью**: использовать только подпись.
- **Альбомы**: склеивать подписи по порядку.
- Игнорировать вложения без текста.
- Будущие расширения (без реализации сейчас): ссылки на YouTube/файлы видео для транскрибации; фото для OCR.

**Сбор и буферизация**

- Единица обработки — **сессия** (по `user_id`).
- Буферизация сообщений в режиме **Curate**:

  - старт сессии: первое полученное сообщение;
  - окно бездействия **60 сек** → автостарт обработки;
  - явный старт по кнопке «Обработать сейчас».
- Дедуп по `message_id` и хешу текста (SHA-256) внутри активной сессии.

**Ограничения и разбиение**

- Макс. длина одного сообщения: использовать нативные лимиты Telegram; многочастные тексты **склеивать** в исходном порядке.
- Критерий разбиения (для LLM промптов уже задан): короткие → 1–2 инсайта; длинные → 3–30 атомарных инсайтов/заметок.

**Ф low обработки**

1. Принять/накопить входящие тексты → `/ingest/text` (API) с метаданными (`source_url?`, `author?`, `dt?`, `channel?`).
2. Получить список созданных заметок → выслать:

   - ссылки на просмотр в Mini App;
   - кнопку «Скачать ZIP» (ендпоинт `/export/zip`);
   - (опц.) предпросмотр первой заметки как файла `.md`.
3. Показать CTA «Открыть Mini App» (кнопка WebApp).

**Безопасность и вебхук**

- Валидация апдейтов Telegram по IP не требуется; проверять корректность токена и секретного пути.

**UX-детали**

- Сообщения о ходе: «Принял N сообщений…», «Идёт обработка…», «Готово: создано M заметок».
- Ошибки: лаконичные и полезные («Текст пустой», «Превышен лимит», «Попробуй позже»).
- Интернационализация: RU/EN по умолчанию, команда `/lang` для фикса.

---

### 6.2. Telegram Mini App (Next.js WebApp)

**Цель:** «обсидиановский» просмотр и поиск без выхода из Telegram; мгновенные действия: скачать ZIP, открыть в локальном Obsidian.

**Аутентификация**

- Авторизация через **Telegram WebApp initData**.
- На бэкенде проверять подпись `initData` (HMAC-SHA256 с токеном бота).
- Сессия — бессерверная или привязка по `telegram_id` в запросах к API.

**Навигация и страницы**

- **Notes List**: список заметок с пагинацией/виртуализацией.

  - Быстрые фильтры: **теги**, период (дата создания), источник (канал/автор).
  - Сортировки: по дате, названию.
- **Note View**: рендер Markdown (безопасный), YAML-мета сверху (title, tags, source, created).

  - Блок **«См. также»** (из заметки) как кликабельные ссылки.
  - Кнопки: **Open in Obsidian** (`obsidian://...`), **Скачать .md**, **Скопировать ссылку**.
- **Search**: поле ввода → запрос в API:

  - показать **Top-K сниппетов** (заголовок, кусочек текста, ссылка);
  - кнопка «Показать ответ ассистента» → вызвать RAG-ответ (LLM 5-nano) и отрендерить Markdown-ответ + «См. также».
- **Actions / Меню**: «Download ZIP» (вызов `/export/zip`), «Создать MOC» (если включено), «Открыть бота».

**Интеракции и состояние**

- Реактивные фильтры и поиск.
- Сохранение последних фильтров в `localStorage` (внутри WebApp) до закрытия.
- Индикация загрузки/ошибок; ретрай кнопки.

**Функции заметок и совместимость с Obsidian**

- Файлы `.md` соответствуют требованиям разделов ТЗ (YAML, «Тезисы», «См. также»).
- Кнопка **Open in Obsidian** формирует `obsidian://advanced-uri` (если у пользователя настроен локальный вальт).
- Для пользователей без Obsidian — скачивание `.md` и ZIP всего вальта.

**Поиск (RAG)**

- Кнопка «Поиск» → `/search` (API):

  - бэкенд: embed запроса → Milvus.search(k=30) → отбор 5–8 фрагментов → LLM (5-nano) → Markdown-ответ.
  - фронтенд: отобразить ответ и список найденных заметок; переход по клику к Note View.

**Производительность и доступность**

- Виртуализация списков.
- Ленивая загрузка заметок/поиска.
- Адаптивный UI (мобильный first), базовая доступность.

**Опциональные улучшения**

- Быстрые действия: «Отметить как избранное», «Добавить тег».
- Предпросмотр MOC и генерация по клику (через соответствующий API).
- Предзагрузка соседних заметок при навигации.

---

### 6.3. Интеграция Bot ↔ Mini App ↔ API

- **Bot → API**

  - `/ingest/text` — пакетная отправка буферизованного текста и метаданных.
  - `/export/zip` — формирование архива vault.
- **Mini App → API**

  - `/notes`, `/notes/{id}` — список/контент;
  - `/search` — RAG-поиск;
  - `/export/zip` — скачать архив;
  - (резерв) `/ingest/video`, `/ingest/image` — для будущих функций транскрибации/OCR.
- **Ссылки**

  - Для каждой заметки отдавать стабильный `note_url` (используется и в боте, и в мини-аппе).

---

## 7) Пайплайны

### Ingest (универсальный: короткие посты и длинные тексты)

1) Нормализация входа (опционально).
2) **LLM (gpt‑5‑structured) → insights JSON** (см. промпты ниже).
3) Для каждого insight: **LLM (gpt‑5‑structured) → Markdown** (YAML+тело) → сохранить на FS.
4) **Chunking**:
   - Короткие посты: 1 чанк (или 1–2 по заголовкам).
   - Длинные: по заголовкам/абзацам, 200–500 символов на чанк.
5) **Embeddings** (`BGE‑M3`) → `Milvus.upsert`.

### Search (RAG)

1) `embed(query)` → `Milvus.search(k=30)`.
2) Отбор 5–8 релевантных сниппетов (+ ссылки).
3) **LLM (gpt‑5‑nano)** → ответ строго из CONTEXT (см. промпты).
4) Вернуть `answer_md` + список.

---

## 8) Промпты (расширенные, готовые)

> **Общие правила:**
>
> - На JSON‑шаге **возвращать ТОЛЬКО JSON** (никаких комментариев).
> - На Markdown‑шаге **возвращать ТОЛЬКО один Markdown‑документ**.
> - RU/EN — распознавать автоматически, сохранять термины.
> - Не выдумывать факты; неопределённость явно помечать.

### 8.1 Разбиение на инсайты (короткие посты и длинные тексты)

**system** (gpt‑5‑structured)

```text
Ты — редактор знаний. Выделяй «чистое знание» из входного текста разной длины:
— короткие посты: 1–3 компактных insights;
— длинные тексты: 5–30 insights, объединённых по смыслу.
Каждый insight — атомная единица знания (1 мысль/правило/шаг).
Удаляй рекламу/воду, сохраняй важные caveats.

Верни строго JSON по схеме:
{
  "insights": [
    {
      "id": "i-<uuid-like>",
      "title": "≤80 символов",
      "summary": "1–3 предложения сути",
      "bullets": ["атомный тезис 1", "атомный тезис 2", "..."],
      "tags": ["до 5 коротких тегов"],
      "confidence": 0.0..1.0
    }
  ]
}
Никаких комментариев вне JSON.
```

**user**

```text
Текст:
<<<
{{RAW_TEXT}}
>>>
Метаданные (опц.): source_url={{URL}}, author={{AUTHOR}}, dt={{DATETIME}}, channel={{CHANNEL}}
Задача: верни JSON по схеме. Если текста мало — верни 1–2 insights.
```

### 8.2 Тематическая группировка (опционально на MVP)

**system** (gpt‑5‑structured)

```text
Ты — куратор. Сгруппируй список инсайтов по 10–30 темам.
Верни JSON:
{
  "topics": [
    {"topic_id":"t-<id>","title":"название темы","desc":"1–2 предложения",
     "insight_ids":["i-1","i-2","..."]}
  ],
  "orphans":["i-..."]
}
Без комментариев вне JSON.
```

**user**

```text
Инсайты (id, title, summary):
<<<
{{LIST_OF_INSIGHTS}}
>>>
Сгруппируй и верни JSON.
```

### 8.3 Генерация Obsidian‑заметки из инсайта

**system** (gpt‑5‑structured)

```text
Ты — генератор Obsidian‑заметок. Верни ровно ОДИН Markdown‑документ.
Требования:
- YAML: title, created (ISO), tags[], source_url?, source_author?, source_dt?, topic_id?
- Тело:
  - 3–5 предложений описания (суть из summary);
  - Раздел "Тезисы": маркдаун‑список из bullets (каждый — 1 факт/правило);
  - (опц.) "Применение": когда и как использовать;
  - "Источники": список ссылок (если есть source_url);
  - (опц.) "См. также": до 5 [[Заголовок]] из предоставленного списка candidates.
Никаких комментариев вне Markdown. Строго сохраняй смысл, не выдумывай факты.
```

**user**

```text
Данные:
title="{{INSIGHT.title}}"
summary="{{INSIGHT.summary}}"
bullets={{INSIGHT.bullets}}
tags={{INSIGHT.tags}}
meta: source_url={{URL}}, source_author={{AUTHOR}}, source_dt={{DATETIME}}, topic_id={{TOPIC_ID}}
Кандидаты для "См. также": {{CANDIDATE_TITLES_JSON_ARRAY}}
Сгенерируй один Markdown.
```

### 8.4 MOC (карта содержания) по темам (опционально)

**system** (gpt‑5‑structured)

```text
Ты — редактор MOC. Верни один Markdown с оглавлением по темам.
Для каждой темы: "## {{title}}" и список "- [[NoteTitle]] — 1 строка описания".
Без комментариев вне Markdown.
```

**user**

```text
Темы и заметки:
{{TOPICS_JSON}}
Сгенерируй один Markdown MOC.
```

### 8.5 Автолинки «См. также» (если нет эмбеддингов)

**system** (gpt‑5‑structured)

```text
Ты — помощник связей. По заголовку/summary текущей заметки выбери до 5 релевантных из списка кандидатов.
Верни JSON: {"related_titles":["...", "..."]} без комментариев.
```

**user**

```text
Текущая заметка: title="{{CUR_TITLE}}", summary="{{CUR_SUMMARY}}"
Кандидаты: {{ALL_TITLES_JSON_ARRAY}}
Верни JSON.
```

### 8.6 Ответ в поиске (RAG)

**system** (gpt‑5‑nano)

```text
Ты — ассистент базы заметок. Отвечай ТОЛЬКО по CONTEXT (список фрагментов).
Если ответа нет — скажи "не нашёл в базе".
В конце дай раздел "См. также" со списком до 5 заметок (title → ссылка).
Верни Markdown.
```

**user**

```text
QUERY: {{user_query}}
CONTEXT:
1) [{{note_title}}] {{snippet}} ({{url}})
2) ...
Сформируй краткий, точный ответ только из CONTEXT.
```

---

## 9) Критерии готовности (DoD)

- `docker compose up -d --build` поднимает все контейнеры.
- `POST /ingest/text`:
  - **Короткий пост** → создаётся 1 заметка (или 1–2 при явных подтемах).
  - **Длинный ввод** (≥ 5k символов) → создаётся 5–30 заметок по смысловым инсайтам.
  - Заметки на FS (Markdown+YAML), проиндексированы в Milvus (chunking:
    - короткие: 1–2 чанка;
    - длинные: 200–500 символов на чанк).
- `POST /search` возвращает осмысленный `answer_md` с «См. также».
- Mini App отображает список заметок, просмотр, поиск, «Download ZIP», «Open in Obsidian».
- Бот обрабатывает пересланные сообщения: 1) короткие — сразу заметка, 2) длинные — набор заметок.

* Бот корректно принимает короткие и длинные тексты, буферизует в режиме **Curate**, запускает обработку по таймауту/кнопке, выдаёт ссылки и ZIP.
- Mini App отображает список, заметку, поиск (Top-K + LLM-ответ) и выполняет действия: **Open in Obsidian**, **Download .md/ZIP**.
- Аутентификация Mini App через Telegram `initData` проходит верификацию на бэкенде.

- **Критерий разбиения:** при длинном вводе итоговые инсайты/заметки должны быть:
  - атомарными (1 основная мысль/правило на заметку),
  - самодостаточными (читабельны отдельно),
  - связанными («См. также» присутствует там, где есть тематическая близость).

---

## 10) Будущее (зарезервировать интерфейсы)

- Планируется интеграция **транскрибации видео** и **чтения текста с фото (OCR)**, обе — через **OpenAI‑модели** по **Replicate API**.
- Зарезервировать эндпоинты (без реализации): `POST /ingest/video`, `POST /ingest/image`.
